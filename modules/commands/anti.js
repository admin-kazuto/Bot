const fs = require('fs-extra');
const path = require('path');
const axios = require('axios');
const moment = require('moment-timezone');

const filePath = path.join(__dirname, '../../Data_Vtuan/data/namebox.json');
const antiImageFolderPath = path.join(__dirname, '../../Data_Vtuan/data/antiImages');
const antiImageFilePath = path.join(__dirname, '../../Data_Vtuan/data/antiImages/antiImage.json');
const antiSpamPath = path.join(__dirname, '../../Data_Vtuan/data/antispamStatus.json');

fs.ensureFileSync(filePath);
let data = fs.readJsonSync(filePath, { throws: false }) || [];
let antiSpamStatus = fs.existsSync(antiSpamPath) ? JSON.parse(fs.readFileSync(antiSpamPath)) : [];
let usersSpam = {};

function createAntiImageFolderIfNotExist() {
    fs.ensureDirSync(antiImageFolderPath);
}

function createAntiImageFileIfNotExist() {
    if (!fs.existsSync(antiImageFilePath)) {
        fs.writeJsonSync(antiImageFilePath, []);
    }
}

module.exports.config = {
    Rent: 2,
    hasPermssion: 1,
    credits: "Vtuan",
    name: "anti",
    commandCategory: "Qu·∫£n Tr·ªã Vi√™n",
    usages: "anti",
    version: "6.0.0",
    cooldowns: 0,
    description: 'anti',
};

module.exports.run = async ({ api, event, args, Threads }) => {
    const { threadID, messageID } = event;
    const threadInfo = await api.getThreadInfo(threadID);
    const threadName = threadInfo.threadName;
    const { PREFIX } = global.config;
    let threadSetting = global.data.threadData.get(threadID) || {};
    let prefix = threadSetting.PREFIX || PREFIX;

    if (!args[0]) {
        return api.sendMessage(`
=== „Äé ùêáùêíùêõùê®ùê± „Äè ===
|‚Ä£ ${prefix}ùêöùêßùê≠ùê¢ ùêßùêöùê¶ùêûùêõùê®ùê±: ùê®ùêß/ùê®ùêüùêü-ùêúùê°ùê®ÃÇÃÅùêßùê† ƒëùê®ÃÇÃâùê¢ ùê≠ùêûÃÇùêß ùêßùê°ùê®ÃÅùê¶
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
|‚Ä£ ${prefix}ùêöùêßùê≠ùê¢ ùê¨ùê©ùêöùê¶: ùê®ùêß/ùê®ùêüùêü-ùêúùê°ùê®ÃÇÃÅùêßùê† ùê¨ùê©ùêöùê¶ ùê≠ùê¢ùêß ùêßùê°ùêöÃÜÃÅùêß 
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
|‚Ä£ ${prefix}ùêöùêßùê≠ùê¢ ùêöùêØùê≠ùêõùê®ùê±: ùê®ùêß/ùê®ùêüùêü-ùêúùê°ùê®ÃÇÃÅùêßùê† ƒëùê®ÃÇÃâùê¢ ùêöÃâùêßùê° ùêßùê°ùê®ÃÅùê¶
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
|‚Ä£ ${prefix}ùêöùêßùê≠ùê¢ ùê®ùêÆùê≠ - ùêúùê°ùê®ÃÇÃÅùêßùê† ùê≠ùê°ùêöÃÄùêßùê° ùêØùê¢ùêûÃÇùêß ùê®ùêÆùê≠ ùêúùê°ùêÆÃÄùêö
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
|‚Ä£ ${prefix}ùêöùêßùê≠ùê¢ ùê™ùê≠ùêØ - ùê°ùêöÃ£ùêß ùêúùê°ùêûÃÇÃÅ ùê§ùê°ùêöÃâ ùêßùêöÃÜùêßùê† ùêúùêÆÃõùê®ÃõÃÅùê© ùêõùê®ùê±
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
     ${moment().tz('Asia/Ho_Chi_Minh').format('HH:mm:ss')} || ${moment().tz('Asia/Ho_Chi_Minh').format('DD/MM/YYYY')}
        `, threadID, messageID);
    }

    switch (args[0]) {
        case "namebox":
            if (args.length !== 2 || (args[1] !== "on" && args[1] !== "off")) {
                return api.sendMessage(`${prefix}anti namebox on ƒë·ªÉ b·∫≠t ch·ªëng ƒë·ªïi t√™n nh√≥m\n${prefix}anti namebox off ƒë·ªÉ t·∫Øt.`, threadID, messageID);
            }

            let threadEntry = data.find(entry => entry.threadID === threadID);
            if (args[1] === "on") {
                if (!threadEntry) {
                    threadEntry = { threadID: threadID, namebox: threadName, status: true };
                    data.push(threadEntry);
                } else {
                    threadEntry.status = true;
                    threadEntry.namebox = threadName;
                }
            } else if (args[1] === "off") {
                if (threadEntry) threadEntry.status = false;
            }

            try {
                fs.writeJsonSync(filePath, data);
                api.sendMessage(`ƒê√£ ${threadEntry.status ? "b·∫≠t" : "t·∫Øt"} ch·ª©c nƒÉng ch·ªëng ƒë·ªïi t√™n nh√≥m ${threadEntry.namebox}`, threadID, messageID);
            } catch (error) {
                api.sendMessage("ƒê√£ x·∫£y ra l·ªói khi c·ªë g·∫Øng c·∫≠p nh·∫≠t c√†i ƒë·∫∑t, vui l√≤ng th·ª≠ l·∫°i sau.", threadID, messageID);
                console.error("Kh√¥ng th·ªÉ ghi v√†o t·ªáp namebox.json:", error);
            }
            break;

        case "spam":
            const infoThread = await api.getThreadInfo(threadID);
            const adminIDs = infoThread.adminIDs.map(e => e.id);
            const idBot = api.getCurrentUserID();

            switch (args[1]) {
                case "setspam":
                    if (!adminIDs.includes(idBot)) {
                        api.sendMessage("Bot ph·∫£i l√† qu·∫£n tr·ªã vi√™n th√¨ m·ªõi setspam ƒë∆∞·ª£c nh√©<3", threadID);
                        return;
                    }
                    let newCount = parseInt(args[2]);
                    let newTime = parseInt(args[3]);
                    if (isNaN(newCount) || isNaN(newTime)) {
                        api.sendMessage("Vui l√≤ng cung c·∫•p s·ªë l·∫ßn tin nh·∫Øn v√† th·ªùi gian h·ª£p l·ªá.", threadID);
                        return;
                    }
                    const index = antiSpamStatus.findIndex(setting => setting.threadID === threadID);
                    if (index !== -1) {
                        antiSpamStatus[index].spamCount = newCount;
                        antiSpamStatus[index].spamTime = newTime;
                    } else {
                        antiSpamStatus.push({ threadID, spamCount: newCount, spamTime: newTime, status: false });
                    }
                    fs.writeFileSync(antiSpamPath, JSON.stringify(antiSpamStatus, null, 4));
                    api.sendMessage(`ƒê√£ c√†i ƒë·∫∑t scan antispam ${newCount}/${newTime/1000}s\nD√πng ${global.config.PREFIX}antispam on ƒë·ªÉ b·∫≠t ch·∫ø ƒë·ªô ch·ªëng spam<3`, threadID);
                    break;
                case "on":
                    const settingOn = antiSpamStatus.find(setting => setting.threadID === threadID);
                    if (!settingOn) {
                        api.sendMessage(`D√πng ${global.config.PREFIX}antispam setspam <s·ªë tin nh·∫Øn> <time> ƒë·ªÉ c√†i ƒë·∫∑t th√¥ng s·ªë`, threadID);
                        return;
                    }
                    settingOn.status = true;
                    fs.writeFileSync(antiSpamPath, JSON.stringify(antiSpamStatus, null, 4));
                    api.sendMessage('ƒê√£ b·∫≠t ch·∫ø ƒë·ªô ch·ªëng spam!', threadID);
                    break;
                case "off":
                    const settingOff = antiSpamStatus.find(setting => setting.threadID === threadID);
                    if (settingOff) {
                        settingOff.status = false;
                        fs.writeFileSync(antiSpamPath, JSON.stringify(antiSpamStatus, null, 4));
                        api.sendMessage('ƒê√£ t·∫Øt ch·∫ø ƒë·ªô ch·ªëng spam!', threadID);
                    }
                    break;
                default:
                    api.sendMessage("D√πng antispam setspam/on/off [count] [time]", threadID);
            }
            break;

        case "avtbox":
            const cmdImage = args[1];
            const threadIDStr = event.threadID.toString();
            let antiImageData = await fs.readJson(antiImageFilePath).catch(() => []);
            let threadData = antiImageData.find(item => item.id === threadIDStr);

            if (cmdImage === 'on') {
                createAntiImageFolderIfNotExist(antiImageFolderPath);

                if (!threadData) {
                    threadData = { id: threadIDStr, status: true };
                    antiImageData.push(threadData);
                } else {
                    threadData.status = true;
                }

                const threadInfo = await api.getThreadInfo(threadID);
                const imageUrl = threadInfo.imageSrc;
                threadData.imageURL = imageUrl;

                const response = await axios({
                    method: 'get',
                    url: imageUrl,
                    responseType: 'stream',
                });

                const fileName = `${threadIDStr}.jpg`;
                const imagePath = path.join(antiImageFolderPath, fileName);
                const writer = fs.createWriteStream(imagePath);
                response.data.pipe(writer);

                await new Promise((resolve, reject) => {
                    writer.on('finish', resolve);
                    writer.on('error', reject);
                });

                await fs.writeJson(antiImageFilePath, antiImageData, { spaces: 4 });

                api.sendMessage(`ƒê√£ b·∫≠t anti ·∫£nh nh√≥m!`, threadID);
            } else if (cmdImage === 'off') {
                if (threadData) {
                    threadData.status = false;
                    const imageFilePath = path.join(antiImageFolderPath, `${threadIDStr}.jpg`);
                    if (fs.existsSync(imageFilePath)) {
                        fs.unlinkSync(imageFilePath);
                    }
                    api.sendMessage('ƒê√£ t·∫Øt anti ·∫£nh nh√≥m!', threadID);
                } else {
                    api.sendMessage('ƒê√£ b·∫≠t anti ·∫£nh ƒë√©o ƒë√¢u m√† t·∫Øt?', threadID);
                }
            } else {
                api.sendMessage(`D√πng ${global.config.PREFIX}avtbox on ho·∫∑c off ƒë·ªÉ b·∫≠t/t·∫Øt theo √Ω mu·ªën`, threadID);
            }
            await fs.writeJson(antiImageFilePath, antiImageData, { spaces: 4 });
            break;

        case "out":
            let dataAntiout = (await Threads.getData(event.threadID)).data || {};
            if (typeof dataAntiout["antiout"] === "undefined" || dataAntiout["antiout"] === false) {
                dataAntiout["antiout"] = true;
            } else {
                dataAntiout["antiout"] = false;
            }
            await Threads.setData(event.threadID, { data: dataAntiout });
            global.data.threadData.set(parseInt(event.threadID), dataAntiout);
            return api.sendMessage(`${dataAntiout["antiout"] ? "b·∫≠t" : "t·∫Øt"} th√†nh c√¥ng ch·ª©c nƒÉng ch·ªëng th√†nh vi√™n out ch√πa`, event.threadID);

        case "qtv":
            const info = await api.getThreadInfo(event.threadID);
            if (!info.adminIDs.some(item => item.id == api.getCurrentUserID())) {
                return api.sendMessage({ body: 'Bot ch∆∞a l√† qu·∫£n tr·ªã vi√™n!!' }, event.threadID, event.messageID);
            }
            const dataQtv = (await Threads.getData(event.threadID)).data || {};
            if (typeof dataQtv["guard"] === "undefined" || dataQtv["guard"] === false) {
                dataQtv["guard"] = true;
            } else {
                dataQtv["guard"] = false;
            }
            await Threads.setData(event.threadID, { data: dataQtv });
            global.data.threadData.set(parseInt(event.threadID), dataQtv);
            return api.sendMessage({ body: `ƒê√£ ${dataQtv["guard"] ? "b·∫≠t" : "t·∫Øt"} th√†nh c√¥ng anti thay ƒë·ªïi qu·∫£n tr·ªã vi√™n` }, event.threadID, event.messageID);

        default:
            return api.sendMessage('T√πy ch·ªçn kh√¥ng h·ª£p l·ªá.', event.threadID, event.messageID);
    }
};

module.exports.handleEvent = async function ({ api, event, Users }) {
    const { threadID, senderID } = event;
    const threadInfo = await api.getThreadInfo(threadID);
    const adminIDs = threadInfo.adminIDs.map(admin => admin.id);
    const adminBot = global.config.ADMINBOT || [];

    if (adminBot.includes(senderID) || adminIDs.includes(senderID)) return;

    let antispamData = JSON.parse(fs.readFileSync(antiSpamPath, "utf-8"));
    let threadAntispamData = antispamData.find(item => item.threadID === event.threadID.toString());

    if (threadAntispamData && threadAntispamData.status === true) {
        if (!usersSpam[senderID]) {
            usersSpam[senderID] = { count: 0, start: Date.now() };
        }

        usersSpam[senderID].count++;
        let name = await Users.getNameUser(senderID);
        if (Date.now() - usersSpam[senderID].start > threadAntispamData.spamTime) {
            if (usersSpam[senderID].count > threadAntispamData.spamCount) {
                api.removeUserFromGroup(senderID, threadID);
                api.sendMessage({
                    body: `ƒê√£ t·ª± ƒë·ªông kick ${name} do spam`}, threadID);
            }
            usersSpam[senderID].count = 0;
            usersSpam[senderID].start = Date.now();
        }
    }
};
